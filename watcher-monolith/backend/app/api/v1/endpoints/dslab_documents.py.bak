"""
游빍 DS Lab - Endpoints para gesti칩n de documentos
"""
from fastapi import APIRouter, HTTPException, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy import func, desc, and_
from typing import List, Optional
from datetime import datetime

from app.db.session import get_db
from app.db.models import BoletinDocument, AnalysisResult
from app.schemas.dslab import (
    BoletinDocumentCreate,
    BoletinDocumentUpdate,
    BoletinDocumentResponse,
    DocumentStats
)

router = APIRouter()


@router.post("/documents", response_model=BoletinDocumentResponse, status_code=201)
async def register_document(
    document: BoletinDocumentCreate,
    db: Session = Depends(get_db)
):
    """
    Registrar un documento de bolet칤n en la base de datos
    """
    # Verificar si ya existe
    existing = db.query(BoletinDocument).filter(
        BoletinDocument.filename == document.filename
    ).first()
    
    if existing:
        raise HTTPException(status_code=409, detail="Documento ya existe")
    
    # Crear nuevo documento
    db_document = BoletinDocument(**document.dict())
    db.add(db_document)
    db.commit()
    db.refresh(db_document)
    
    return db_document


@router.get("/documents", response_model=List[BoletinDocumentResponse])
async def list_documents(
    year: Optional[int] = None,
    month: Optional[int] = None,
    section: Optional[int] = None,
    status: Optional[str] = None,
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    db: Session = Depends(get_db)
):
    """
    Listar documentos con filtros opcionales
    """
    query = db.query(BoletinDocument)
    
    if year:
        query = query.filter(BoletinDocument.year == year)
    if month:
        query = query.filter(BoletinDocument.month == month)
    if section:
        query = query.filter(BoletinDocument.section == section)
    if status:
        query = query.filter(BoletinDocument.analysis_status == status)
    
    documents = query.order_by(
        desc(BoletinDocument.year),
        desc(BoletinDocument.month),
        desc(BoletinDocument.day)
    ).offset(skip).limit(limit).all()
    
    return documents


@router.get("/documents/{document_id}", response_model=BoletinDocumentResponse)
async def get_document(
    document_id: int,
    db: Session = Depends(get_db)
):
    """
    Obtener un documento por ID
    """
    document = db.query(BoletinDocument).filter(
        BoletinDocument.id == document_id
    ).first()
    
    if not document:
        raise HTTPException(status_code=404, detail="Documento no encontrado")
    
    return document


@router.put("/documents/{document_id}", response_model=BoletinDocumentResponse)
async def update_document(
    document_id: int,
    update_data: BoletinDocumentUpdate,
    db: Session = Depends(get_db)
):
    """
    Actualizar un documento
    """
    document = db.query(BoletinDocument).filter(
        BoletinDocument.id == document_id
    ).first()
    
    if not document:
        raise HTTPException(status_code=404, detail="Documento no encontrado")
    
    # Actualizar campos
    update_dict = update_data.dict(exclude_unset=True)
    for key, value in update_dict.items():
        setattr(document, key, value)
    
    document.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(document)
    
    return document


@router.get("/documents/{document_id}/history")
async def get_document_history(
    document_id: int,
    db: Session = Depends(get_db)
):
    """
    Obtener historial de an치lisis de un documento
    """
    document = db.query(BoletinDocument).filter(
        BoletinDocument.id == document_id
    ).first()
    
    if not document:
        raise HTTPException(status_code=404, detail="Documento no encontrado")
    
    # Obtener todos los an치lisis del documento
    results = db.query(AnalysisResult).filter(
        AnalysisResult.document_id == document_id
    ).order_by(desc(AnalysisResult.analyzed_at)).all()
    
    return {
        "document": document,
        "total_analyses": len(results),
        "analyses": [
            {
                "execution_id": r.execution_id,
                "config_id": r.config_id,
                "transparency_score": r.transparency_score,
                "risk_level": r.risk_level,
                "num_red_flags": r.num_red_flags,
                "analyzed_at": r.analyzed_at
            }
            for r in results
        ]
    }


@router.get("/documents/stats", response_model=DocumentStats)
async def get_documents_stats(
    year: Optional[int] = None,
    db: Session = Depends(get_db)
):
    """
    Obtener estad칤sticas de documentos
    """
    query = db.query(BoletinDocument)
    
    if year:
        query = query.filter(BoletinDocument.year == year)
    
    # Total documentos
    total_documents = query.count()
    
    # Por status
    status_stats = db.query(
        BoletinDocument.analysis_status,
        func.count(BoletinDocument.id)
    ).filter(
        BoletinDocument.year == year if year else True
    ).group_by(BoletinDocument.analysis_status).all()
    
    by_status = {status: count for status, count in status_stats}
    
    # Por mes
    month_stats = db.query(
        BoletinDocument.year,
        BoletinDocument.month,
        func.count(BoletinDocument.id)
    ).filter(
        BoletinDocument.year == year if year else True
    ).group_by(
        BoletinDocument.year,
        BoletinDocument.month
    ).all()
    
    by_month = {f"{y}-{m:02d}": count for y, m, count in month_stats}
    
    # Tama침o total
    total_size_bytes = db.query(
        func.sum(BoletinDocument.file_size_bytes)
    ).filter(
        BoletinDocument.year == year if year else True
    ).scalar() or 0
    
    total_size_mb = total_size_bytes / (1024 * 1024)
    
    # Promedio de p치ginas
    avg_pages = db.query(
        func.avg(BoletinDocument.num_pages)
    ).filter(
        and_(
            BoletinDocument.num_pages.isnot(None),
            BoletinDocument.year == year if year else True
        )
    ).scalar()
    
    return DocumentStats(
        total_documents=total_documents,
        by_status=by_status,
        by_month=by_month,
        total_size_mb=round(total_size_mb, 2),
        avg_pages=round(avg_pages, 1) if avg_pages else None
    )


@router.post("/documents/batch-register")
async def batch_register_documents(
    documents: List[BoletinDocumentCreate],
    db: Session = Depends(get_db)
):
    """
    Registrar m칰ltiples documentos de una vez
    """
    registered = []
    skipped = []
    errors = []
    
    for doc_data in documents:
        try:
            # Verificar si ya existe
            existing = db.query(BoletinDocument).filter(
                BoletinDocument.filename == doc_data.filename
            ).first()
            
            if existing:
                skipped.append(doc_data.filename)
                continue
            
            # Crear documento
            db_document = BoletinDocument(**doc_data.dict())
            db.add(db_document)
            registered.append(doc_data.filename)
            
        except Exception as e:
            errors.append({
                "filename": doc_data.filename,
                "error": str(e)
            })
    
    # Commit en batch
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error en commit: {str(e)}")
    
    return {
        "registered": len(registered),
        "skipped": len(skipped),
        "errors": len(errors),
        "details": {
            "registered_files": registered,
            "skipped_files": skipped,
            "error_details": errors
        }
    }

